#! /usr/bin/ruby

class Obfuscator
  # Simple entry point - just delegate to other functionality
  def obfuscate_file(args)
    contents = parse_args(args)
    character_set = get_character_set(contents)
    metrics = get_character_metrics(contents)
    location_metrics = character_metrics_to_location_array(character_set, metrics)
    divmods = add_divmods_to_all_locations(location_metrics)
    intersection = lowest_intersecting_solution(divmods)
    locations_with_solutions = add_solution_to_locations(intersection, divmods)
    puts character_set.join.dump
    puts locations_with_solutions
  end
  # @param [Array] args the arguments to the script. must be one element,
  #   consisting of a string representing the path to a file on disk @return
  # @return [String] the contents of the given file path
  def parse_args(args)
    if args.size == 1 && file_contents = File.read(args[0])
      puts "parsing file #{args[0]}"
    else
      raise "could not read file at path #{args[0]}"
    end
    file_contents
  end

  # @param [String] file_contents the contents of the ascii art image to
  #   obfuscate
  # @return [Array] an Array containing a single instance of every character in
  #   order of appearance in file_contents. We use Array rather than Set because
  #   its more full-featured in ruby.
  def get_character_set(file_contents)
    file_contents.split('').uniq
  end

  # @todo refactor - this is too complicated
  # @param [String] file_contents the contents of the ascii art image to obfuscate
  # @return [Array[Hash]] array of hashes containing {:char => char, :count => count of char}
  def get_character_metrics(file_contents)
    # first, generate an array of hashes representing an ordered list of
    # characters with the associated number of consecutive times it appears in the
    # text, before another character appears
    characters_with_count = []
    # split the file_contents into an array of characters
    contents_list = file_contents.split('')
    previous_char = contents_list[0]
    previous_char_count = 0

    contents_list.each_with_index do |char, index|
      if char == previous_char
        previous_char_count += 1
      else
        characters_with_count << { :char => previous_char, :count => previous_char_count }
        previous_char = char
        previous_char_count = 1
      end
      # Make sure we don't lose the last element
      if index == contents_list.length - 1
        characters_with_count << { :char => previous_char, :count => previous_char_count }
      end
    end
    characters_with_count
  end

  # Given a set of characters and the array of hashes generated by
  # get_character_metrics, generate a new form of metrics. We want the index of
  # the character in the array, and the count. We don't need the character
  # itself anymore with our set. This looks like:
  # [
  #   { :index => 0, :count => 2 }
  #   { :index => 1, :count => 4 }
  # ]
  # @param [Array] character_set an array of unique characters
  # @param [Array[Hash]] character_metrics an array of hashes generated by
  #   #get_character_metrics
  # @return [Array[Hash]] array of {:index => Integer, :count => Integer}
  #   elements
  def character_metrics_to_location_array(character_set, character_metrics)
    location_array = []
    character_metrics.each do |char_and_count|
      char = char_and_count[:char]
      count = char_and_count[:count]
      location_array << {:index => character_set.index(char), :count => count }
    end
    location_array  
  end

  # @param [Array[Hash]] location_array array of {:index => Integer, :count =>
  #   Integer} elements
  # @return [Array[Hash]] an array of the same hashes, each with an additional {key =>
  #   value} pair, :solutions, whose value is the set of solutions returned by
  #   generate_set_of_divmods
  def add_divmods_to_all_locations(location_array)
    results = []
    # split in four to process in parallel

    first_set = location_array.slice(0, location_array.size / 4)
    second_set = location_array.slice(first_set.size, location_array.size / 4)
    third_set = location_array.slice(first_set.size + second_set.size, location_array.size / 4)
    fourth_set = location_array.slice(first_set.size + second_set.size + third_set.size, location_array.size)

    first_results = []
    second_results = []
    third_results = []
    fourth_results = []

    locations = [ 
      {:id => 0, :set => first_set, :results => first_results},
      {:id => 1, :set => second_set, :results => second_results},
      {:id => 2, :set => third_set, :results => third_results},
      {:id => 3, :set => fourth_set, :results => fourth_results}
    ]
    # This is about as naive, hardcoded, as it gets. but i'm tired of working on
    # this and just want to get something to work. Can clean it up later.
    threads = locations.inject([]) do |acc, location|
      acc << Thread.new do
        location[:set].each do |location_and_count|
          # first check if we've already done a calculation for this location,
          # count, and if so use that instead
          if existing_solution = location[:results].find { |elem| elem[:index] == location_and_count[:index] && elem[:count] == location_and_count[:count] }
            puts "[Thread #{location[:id]}] reusing solution for #{location_and_count}"
            location[:results] << existing_solution
          else
            puts "[Thread #{location[:id]}] generating set of divmods for #{location_and_count}"
            solutions = generate_set_of_divmods(location_and_count)
            location[:results] << location_and_count.merge(:solutions => solutions)
          end
        end
      end
    end
    threads.each { |th| th.join }
    locations.each { |location| results = results + location[:results] }
    results
  end

  # @todo refactor - this is too complicated and too slow
  # The business about the right ceiling to use is suboptimal. Tried starting
  # small and increasing the ceiling given no results, but the problem is we
  # need a solution that's common to all of the indexes, which for the higher
  # numbers or more extravagant divmods means a very high operand.
  # @param [Hash] location_and_count {:index => Integer, :count => Integer}
  # @return [Array[Array]] Array of two element arrays representing all possible
  #   divmod operands between 1 and some ceiling that together result in this :index,
  #   :count result. For example, given {:index => 1, :count => 17}, return an
  #   array containing such elements as [54, 37]
  #   If no results are found under ceiling 1000, we fail
  def generate_set_of_divmods(location_and_count)
    index = location_and_count[:index]
    count = location_and_count[:count]
    results = []
    start_outer = 0
    start_inner = 1 # refactor this terrible mess. We start with 1 because we can't divide by 0.
    ceiling = 5000
    (start_outer..ceiling).each do |operand_x|
      (start_inner..ceiling).each do |operand_y|
        if operand_x.divmod(operand_y) == [index, count]
          results << [operand_x, operand_y]
        end
      end
    end
    # if results are still empty, fail.
    if results.empty?
      raise "Could not find a solution to #{location_and_count} given ceiling #{ceiling}"
    else
      results
    end
  end

  # @todo Rename this method
  # @param [Array[Hash]] locations_with_solutions the result of successfully
  #   calculating #add_divmods_to_all_locations, ie an array of hashes, each
  #   containing :index, :count, and :solutions keys
  # @return [Integer] The lowest integer common to the second element of all
  #   solution arrays for all locations.
  #   The second integer is common to all solution entries, and is the shared
  #   operand to divmod such that:
  #     [index, count] == first_integer.divmod(second_integer).
  def lowest_intersecting_solution(locations_with_solutions)
    # We're using a lot of resources here... Gradually build up the set
    # intersection of the whole solution space The complicated part is, we're
    # only looking for the common *second* integer in the two element array.
    # That said, none of the solution sets for any location will contain a
    # duplicate entry, so if we have the value we're looking for we can search
    # the arrays for it deterministically.
    # This is stuplidly expensive. there's a better way.
    intersection = []
    # The second element, count, is the one we need to find in common.
    # First we need to prime the intersection with the first solution set
    locations_with_solutions.first[:solutions].each { |pair| intersection << pair[1] }

    # Now iterate and find the intersection solutions for all locations
    locations_with_solutions.each do |location_with_solutions|
      solutions = location_with_solutions[:solutions]
      current_solution_set = []

      solutions.each do |solution_pair|
        current_solution_set << solution_pair[1]
      end

      # This isn't the bitwise and operator as you'd expect, it's ruby's
      # intersection operator
      new_intersection = intersection & current_solution_set
      if new_intersection.empty?
        raise "Could not find a common solution between current intersection set #{intersection} and #{location_with_solutions}. Possibly need to raise solution set ceiling."
      else
        intersection = new_intersection
      end
    end
    # Now that we have the intersection, return the smallest one
    puts "total intersection is: #{intersection}"
    intersection.min
  end

  # @param [Integer] intersecting_solution the lowest solution common to all second elements
  # @param [Array[Hash]] locations a locations array containing hashes with
  #   index, count, and solutions
  # @return [Array[Hash]] the same locations hash with a new key, :solution,
  #   with a value of the solution pair matching the intersecting solution
  def add_solution_to_locations(intersecting_solution, locations)
    locations.each do |location_with_solutions|
      solutions = location_with_solutions[:solutions]
      solution = solutions.find { |solution_pair| solution_pair[1] == intersecting_solution }
      location_with_solutions[:solution] = solution
    end
    locations
  end
end